/*****
题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的n行*m列的矩阵，矩阵中的每个元素aij均为非负整数。游戏规则如下：
1. 每次取数时须从每行各取走一个元素，共n个。m次后取完矩阵所有的元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和；每行取数的得分 = 被取走的元素值*i，其中i表示第i次取数（从1开始编号）；
4. 游戏结束总得分为m次取数得分之和。
帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。

关于输入

包括n+1行；
第一行为两个用空格隔开的整数n和m。
第2~n+1行为n*m矩阵，其中每行有m个用单个空格隔开
l<=n，m<=80，1<=aij<=1000

关于输出

仅包含1行，为一个整数，即输入矩阵取数后的最大的分。

例子输入

2 3
1 2 3
3 4 2

例子输出

34
*****/
#include<iostream>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
int DP(vector<vector<vector<int>>>&dp,int i,vector<int>& num,int s, int e,int turn) {
	if (dp[i][s][e] != -1) return dp[i][s][e];
	if (s == e) {
		dp[i][s][e]= num[s] * turn;
		return dp[i][s][e];
	}
	dp[i][s][e] = max(DP(dp, i, num, s + 1, e, turn + 1) + num[s] * turn, DP(dp, i, num, s, e - 1, turn + 1) + num[e] * turn);
	return dp[i][s][e];
}
int main() {
	int n, m; cin >> n >> m;
	int sum = 0;
	vector<vector<int>>map(n+1, vector<int>(m + 1, 0));
	vector<vector<vector<int>>>dp(n + 1, vector<vector<int>>(m + 1, vector<int>(m+1,-1)));
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> map[i][j];
	for (int i = 1; i <= n; i++) {
		dp[i][1][m] = DP(dp, i, map[i], 1, m, 1);
		sum += dp[i][1][m];
	}
	cout << sum;
}
